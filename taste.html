<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STEVENSON — Taste Map</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --font: 'IBM Plex Mono', monospace;
    --black: #0a0a0a;
    --white: #fff;
    --dim: rgba(255,255,255,0.5);
    --red: #e53e3e;
  }
  html, body {
    height: 100%; overflow: hidden;
    font-family: var(--font);
    background: #050508;
    color: var(--white);
    -webkit-font-smoothing: antialiased;
  }
  #canvas { width: 100%; height: 100%; display: block; }

  /* ── HUD ── */
  .hud {
    position: fixed; top: 0; left: 0; right: 0;
    padding: 16px 24px;
    display: flex; align-items: center; justify-content: space-between;
    z-index: 10; pointer-events: none;
  }
  .hud > * { pointer-events: auto; }
  .hud-title {
    font-size: 13px; font-weight: 600;
    letter-spacing: 0.12em; text-transform: uppercase;
    color: var(--white); text-decoration: none;
  }
  .hud-right {
    display: flex; align-items: center; gap: 16px;
    font-size: 11px; color: var(--dim);
  }
  .hud-stat { letter-spacing: 0.04em; }
  .hud-stat b { color: var(--white); font-weight: 500; }

  /* ── Color mode buttons ── */
  .color-modes {
    position: fixed; bottom: 24px; left: 24px;
    display: flex; gap: 8px; z-index: 10;
  }
  .mode-btn {
    font-family: var(--font);
    font-size: 10px; letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 5px 10px;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 4px;
    background: rgba(255,255,255,0.05);
    color: var(--dim);
    cursor: pointer;
    transition: all 0.2s;
  }
  .mode-btn:hover { background: rgba(255,255,255,0.1); color: var(--white); }
  .mode-btn.active { background: rgba(255,255,255,0.15); color: var(--white); border-color: rgba(255,255,255,0.3); }

  /* ── Tooltip ── */
  #tooltip {
    position: fixed;
    display: none;
    z-index: 20;
    max-width: 320px;
    pointer-events: none;
  }
  .tooltip-inner {
    display: flex; gap: 12px;
    background: rgba(15,15,20,0.95);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    padding: 10px;
    backdrop-filter: blur(12px);
  }
  .tooltip-img {
    width: 80px; height: 80px;
    object-fit: cover;
    border-radius: 4px;
    flex-shrink: 0;
    background: #1a1a1a;
  }
  .tooltip-text {
    display: flex; flex-direction: column;
    justify-content: center; gap: 3px;
    min-width: 0;
  }
  .tooltip-title {
    font-size: 11px; font-weight: 600;
    line-height: 1.3;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .tooltip-meta {
    font-size: 9px; color: var(--dim);
    letter-spacing: 0.03em;
  }
  .tooltip-score {
    font-size: 10px; font-weight: 500;
    margin-top: 2px;
  }
  .tooltip-liked {
    color: var(--red); font-size: 10px; font-weight: 600;
    letter-spacing: 0.06em;
  }

  /* ── Legend ── */
  .legend {
    position: fixed; bottom: 24px; right: 24px;
    z-index: 10;
    display: flex; align-items: center; gap: 12px;
    font-size: 9px; letter-spacing: 0.05em;
    color: var(--dim); text-transform: uppercase;
  }
  .legend-item {
    display: flex; align-items: center; gap: 5px;
  }
  .legend-dot {
    width: 8px; height: 8px; border-radius: 50%;
  }

  /* ── Loading ── */
  #loading {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 16px; z-index: 100;
    background: #050508;
    font-size: 12px; letter-spacing: 0.08em;
    text-transform: uppercase; color: var(--dim);
  }
  @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
  .loading-dot {
    width: 6px; height: 6px;
    background: var(--white);
    border-radius: 50%;
    animation: pulse 1.2s infinite;
  }
  #loading-status { font-size: 10px; margin-top: 4px; }
</style>
</head>
<body>

<div id="loading">
  <div class="loading-dot"></div>
  <div>Mapping taste space</div>
  <div id="loading-status"></div>
</div>

<div class="hud">
  <a href="/" class="hud-title">STEVENSON</a>
  <div class="hud-right">
    <span class="hud-stat"><b id="total-count">0</b> paintings</span>
    <span class="hud-stat"><b id="liked-count" style="color:var(--red)">0</b> liked</span>
  </div>
</div>

<div class="color-modes">
  <button class="mode-btn active" data-mode="score">Score</button>
  <button class="mode-btn" data-mode="style">Style</button>
  <button class="mode-btn" data-mode="price">Price</button>
  <button class="mode-btn" data-mode="liked">Liked</button>
  <button class="mode-btn" data-mode="source">Source</button>
</div>

<div class="legend" id="legend"></div>
<div id="tooltip"><div class="tooltip-inner" id="tooltip-inner"></div></div>
<canvas id="canvas"></canvas>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three'
import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

const API = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
  ? `http://${window.location.host}` : ''

// ── State ──
let mapData = null     // { ids, coords, meta }
let likedSet = new Set()
let colorMode = 'score'
let hoveredIdx = -1

// ── Style palette ──
const STYLE_COLORS = {
  'oil painting':       [0.90, 0.45, 0.15],  // warm orange
  'watercolor':         [0.30, 0.65, 0.95],  // sky blue
  'acrylic':            [0.85, 0.25, 0.55],  // magenta
  'mixed media':        [0.65, 0.85, 0.30],  // lime
  'pastel':             [0.80, 0.70, 0.90],  // lavender
  'ink':                [0.40, 0.40, 0.50],  // slate
  'pencil':             [0.70, 0.70, 0.65],  // warm gray
  'digital':            [0.20, 0.90, 0.80],  // cyan
  'print':              [0.95, 0.80, 0.30],  // gold
  'photography':        [0.55, 0.55, 0.60],  // cool gray
}
const DEFAULT_STYLE_COLOR = [0.45, 0.45, 0.50]

// ── Setup Three.js ──
const canvas = document.getElementById('canvas')
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true })
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
renderer.setSize(window.innerWidth, window.innerHeight)

const scene = new THREE.Scene()
scene.background = new THREE.Color(0x050508)
scene.fog = new THREE.FogExp2(0x050508, 0.08)

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100)
camera.position.set(0, 0.5, 4)

const controls = new OrbitControls(camera, canvas)
controls.enableDamping = true
controls.dampingFactor = 0.05
controls.rotateSpeed = 0.5
controls.zoomSpeed = 0.8
controls.autoRotate = true
controls.autoRotateSpeed = 0.3
controls.minDistance = 0.5
controls.maxDistance = 10

// ── Point material ──
const pointsMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uSize: { value: 0.8 * renderer.getPixelRatio() },
  },
  vertexShader: `
    attribute vec3 customColor;
    attribute float alpha;
    attribute float size;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uSize;

    void main() {
      vColor = customColor;
      vAlpha = alpha;
      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = size * uSize * (80.0 / -mvPos.z);
      gl_PointSize = clamp(gl_PointSize, 0.5, 10.0);
      gl_Position = projectionMatrix * mvPos;
    }
  `,
  fragmentShader: `
    varying vec3 vColor;
    varying float vAlpha;

    void main() {
      vec2 uv = gl_PointCoord - 0.5;
      float d = length(uv);
      if (d > 0.5) discard;
      float edge = smoothstep(0.5, 0.3, d);
      gl_FragColor = vec4(vColor, vAlpha * edge);
    }
  `,
  transparent: true,
  depthWrite: false,
  blending: THREE.NormalBlending,
})

let pointsGeometry = null
let pointsMesh = null

// ── Load data ──
async function loadData() {
  const status = document.getElementById('loading-status')

  // Fetch taste map (includes liked IDs)
  status.textContent = 'Loading embedding map...'
  const mapRes = await fetch(`${API}/api/taste-map`)
  if (!mapRes.ok) {
    status.textContent = 'Failed to load taste map — run project_3d.py first'
    return
  }
  mapData = await mapRes.json()
  likedSet = new Set(mapData.liked || [])

  status.textContent = 'Building point cloud...'
  await new Promise(r => requestAnimationFrame(r))

  buildPointCloud()

  document.getElementById('total-count').textContent = mapData.ids.length.toLocaleString()
  document.getElementById('liked-count').textContent = likedSet.size
  document.getElementById('loading').style.display = 'none'

  updateColors()
  updateLegend()
}

function buildPointCloud() {
  const n = mapData.ids.length
  const positions = new Float32Array(n * 3)
  const colors = new Float32Array(n * 3)
  const alphas = new Float32Array(n)
  const sizes = new Float32Array(n)

  for (let i = 0; i < n; i++) {
    positions[i * 3]     = mapData.coords[i * 3]
    positions[i * 3 + 1] = mapData.coords[i * 3 + 1]
    positions[i * 3 + 2] = mapData.coords[i * 3 + 2]
    alphas[i] = 0.6
    sizes[i] = 1.0
  }

  pointsGeometry = new THREE.BufferGeometry()
  pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
  pointsGeometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3))
  pointsGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1))
  pointsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1))

  pointsMesh = new THREE.Points(pointsGeometry, pointsMaterial)
  scene.add(pointsMesh)
}

// ── Color modes ──
function updateColors() {
  if (!mapData || !pointsGeometry) return
  const n = mapData.ids.length
  const colors = pointsGeometry.attributes.customColor.array
  const alphas = pointsGeometry.attributes.alpha.array
  const sizes = pointsGeometry.attributes.size.array

  for (let i = 0; i < n; i++) {
    const m = mapData.meta[i]
    const isLiked = likedSet.has(mapData.ids[i])
    let r, g, b, a = 0.35, s = 1.0

    switch (colorMode) {
      case 'score': {
        const t = Math.min(1, Math.max(0, (m.s || 0) / 100))
        // Low (deep blue) → mid (soft white) → high (gold)
        if (t < 0.5) {
          const u = t * 2
          r = 0.12 + u * 0.58; g = 0.12 + u * 0.58; b = 0.4 + u * 0.35
        } else {
          const u = (t - 0.5) * 2
          r = 0.7 + u * 0.3; g = 0.7 - u * 0.1; b = 0.75 - u * 0.5
        }
        a = 0.15 + t * 0.45
        s = 0.4 + t * 1.0
        break
      }
      case 'style': {
        const sc = STYLE_COLORS[m.st] || DEFAULT_STYLE_COLOR
        r = sc[0]; g = sc[1]; b = sc[2]
        a = m.st ? 0.45 : 0.08
        s = m.st ? 0.8 : 0.3
        break
      }
      case 'price': {
        const p = m.p || 0
        if (p === 0) { r = 0.15; g = 0.15; b = 0.15; a = 0.05; s = 0.3 }
        else {
          const t = Math.min(1, Math.max(0, Math.log10(Math.max(1, p)) / 4))
          r = 0.15 + t * 0.8; g = 0.7 - t * 0.4; b = 0.25 - t * 0.15
          a = 0.2 + t * 0.4
          s = 0.5 + t * 1.0
        }
        break
      }
      case 'liked': {
        if (isLiked) {
          r = 0.95; g = 0.15; b = 0.15; a = 0.95; s = 2.5
        } else {
          r = 0.2; g = 0.2; b = 0.25; a = 0.08; s = 0.3
        }
        break
      }
      case 'source': {
        if (m.src === 'cl' || m.src === 'craigslist') {
          r = 0.3; g = 0.65; b = 0.95; a = 0.35; s = 0.8
        } else if (m.src === 'eb' || m.src === 'ebay') {
          r = 0.95; g = 0.55; b = 0.2; a = 0.35; s = 0.8
        } else {
          r = 0.3; g = 0.3; b = 0.35; a = 0.15; s = 0.4
        }
        break
      }
    }

    // Liked paintings get a subtle highlight in non-liked mode
    if (isLiked && colorMode !== 'liked') {
      a = Math.max(a, 0.6)
      s = Math.max(s, 1.8)
    }

    colors[i * 3] = r; colors[i * 3 + 1] = g; colors[i * 3 + 2] = b
    alphas[i] = a
    sizes[i] = s
  }

  pointsGeometry.attributes.customColor.needsUpdate = true
  pointsGeometry.attributes.alpha.needsUpdate = true
  pointsGeometry.attributes.size.needsUpdate = true
}

function updateLegend() {
  const legend = document.getElementById('legend')
  let html = ''

  switch (colorMode) {
    case 'score':
      html = `
        <div class="legend-item"><div class="legend-dot" style="background:#2a2a80"></div>Low</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ddd"></div>Mid</div>
        <div class="legend-item"><div class="legend-dot" style="background:#fcb830"></div>High</div>
      `
      break
    case 'style':
      for (const [style, [r,g,b]] of Object.entries(STYLE_COLORS).slice(0, 6)) {
        const hex = `rgb(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)})`
        const label = style.replace(/\b\w/g, c => c.toUpperCase())
        html += `<div class="legend-item"><div class="legend-dot" style="background:${hex}"></div>${label}</div>`
      }
      break
    case 'price':
      html = `
        <div class="legend-item"><div class="legend-dot" style="background:#3d3d3d"></div>No price</div>
        <div class="legend-item"><div class="legend-dot" style="background:#4dcc5a"></div>$1-100</div>
        <div class="legend-item"><div class="legend-dot" style="background:#cc7a20"></div>$1000+</div>
      `
      break
    case 'liked':
      html = `
        <div class="legend-item"><div class="legend-dot" style="background:#e53e3e"></div>Liked</div>
        <div class="legend-item"><div class="legend-dot" style="background:#3a3a44"></div>Other</div>
      `
      break
    case 'source':
      html = `
        <div class="legend-item"><div class="legend-dot" style="background:#4db3f2"></div>Craigslist</div>
        <div class="legend-item"><div class="legend-dot" style="background:#f29933"></div>eBay</div>
      `
      break
  }

  legend.innerHTML = html
}

// ── Color mode buttons ──
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelector('.mode-btn.active').classList.remove('active')
    btn.classList.add('active')
    colorMode = btn.dataset.mode
    updateColors()
    updateLegend()
  })
})

// ── Raycasting for hover ──
const raycaster = new THREE.Raycaster()
raycaster.params.Points.threshold = 0.02
const mouse = new THREE.Vector2()
const tooltip = document.getElementById('tooltip')
const tooltipInner = document.getElementById('tooltip-inner')

canvas.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1

  raycaster.setFromCamera(mouse, camera)
  const intersects = raycaster.intersectObject(pointsMesh)

  if (intersects.length > 0) {
    const idx = intersects[0].index
    if (idx !== hoveredIdx) {
      hoveredIdx = idx
      showTooltip(idx, e.clientX, e.clientY)
    } else {
      positionTooltip(e.clientX, e.clientY)
    }
    canvas.style.cursor = 'pointer'
    controls.autoRotate = false
  } else {
    hoveredIdx = -1
    tooltip.style.display = 'none'
    canvas.style.cursor = 'grab'
    controls.autoRotate = true
  }
})

canvas.addEventListener('click', () => {
  if (hoveredIdx >= 0 && mapData) {
    const m = mapData.meta[hoveredIdx]
    if (m.u) window.open(m.u, '_blank')
  }
})

function showTooltip(idx, mx, my) {
  if (!mapData) return
  const m = mapData.meta[idx]
  const isLiked = likedSet.has(mapData.ids[idx])

  tooltipInner.innerHTML = `
    ${m.img ? `<img class="tooltip-img" src="${m.img}" alt="">` : ''}
    <div class="tooltip-text">
      <div class="tooltip-title">${esc(m.t || 'Untitled')}</div>
      <div class="tooltip-meta">${[m.a, m.st, m.r].filter(Boolean).join(' · ')}</div>
      <div class="tooltip-score" style="color:${scoreColor(m.s)}">Score ${m.s}${m.p ? ` · $${m.p}` : ''}</div>
      ${isLiked ? '<div class="tooltip-liked">LIKED</div>' : ''}
    </div>
  `
  tooltip.style.display = 'block'
  positionTooltip(mx, my)
}

function positionTooltip(mx, my) {
  const pad = 16
  let x = mx + pad
  let y = my + pad
  const rect = tooltip.getBoundingClientRect()
  if (x + rect.width > window.innerWidth) x = mx - rect.width - pad
  if (y + rect.height > window.innerHeight) y = my - rect.height - pad
  tooltip.style.left = x + 'px'
  tooltip.style.top = y + 'px'
}

function scoreColor(s) {
  const t = Math.min(1, Math.max(0, s / 100))
  if (t < 0.5) return `rgb(${Math.round(60 + t * 380)}, ${Math.round(60 + t * 380)}, ${Math.round(130 + t * 200)})`
  const u = (t - 0.5) * 2
  return `rgb(${Math.round(230 + u * 25)}, ${Math.round(230 - u * 40)}, ${Math.round(230 - u * 155)})`
}

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML }

// ── Resize ──
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
  pointsMaterial.uniforms.uSize.value = 0.8 * renderer.getPixelRatio()
})

// ── Animate ──
function animate() {
  requestAnimationFrame(animate)
  controls.update()
  renderer.render(scene, camera)
}
animate()

// ── Go ──
loadData()
</script>
</body>
</html>
