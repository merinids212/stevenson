<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<title>STEVENSON — Taste Map</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="stv-nav.css">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --font: 'IBM Plex Mono', monospace;
    --black: #0a0a0a;
    --white: #fff;
    --dim: rgba(255,255,255,0.5);
    --red: #e53e3e;
  }
  html, body {
    height: 100%; overflow: hidden;
    font-family: var(--font);
    background: #050508;
    color: var(--white);
    -webkit-font-smoothing: antialiased;
  }
  #canvas { width: 100%; height: 100%; display: block; }

  .hud-stat { letter-spacing: 0.04em; font-size: 10px; color: var(--dim); }
  .hud-stat b { color: var(--white); font-weight: 500; }

  /* ── Color mode buttons ── */
  .color-modes {
    position: fixed;
    bottom: 16px;
    bottom: max(16px, calc(env(safe-area-inset-bottom, 16px) + 4px));
    left: 50%;
    transform: translateX(-50%);
    display: flex; gap: 6px; z-index: 10;
    flex-wrap: nowrap;
  }
  .mode-btn {
    font-family: var(--font);
    font-size: 9px; letter-spacing: 0.05em;
    text-transform: uppercase;
    padding: 5px 8px;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 4px;
    background: rgba(5,5,8,0.7);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    color: var(--dim);
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
    -webkit-tap-highlight-color: transparent;
  }
  .mode-btn:hover { background: rgba(255,255,255,0.1); color: var(--white); }
  .mode-btn.active { background: rgba(255,255,255,0.15); color: var(--white); border-color: rgba(255,255,255,0.3); }

  /* ── Tooltip (desktop only) ── */
  #tooltip {
    position: fixed;
    display: none;
    z-index: 20;
    max-width: 320px;
    pointer-events: none;
  }
  .tooltip-inner {
    display: flex; gap: 12px;
    background: rgba(15,15,20,0.95);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    padding: 10px;
    backdrop-filter: blur(12px);
  }
  .tooltip-img {
    width: 80px; height: 80px;
    object-fit: cover;
    border-radius: 4px;
    flex-shrink: 0;
    background: #1a1a1a;
  }
  .tooltip-text {
    display: flex; flex-direction: column;
    justify-content: center; gap: 3px;
    min-width: 0;
  }
  .tooltip-title {
    font-size: 11px; font-weight: 600;
    line-height: 1.3;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .tooltip-meta {
    font-size: 9px; color: var(--dim);
    letter-spacing: 0.03em;
  }
  .tooltip-score {
    font-size: 10px; font-weight: 500;
    margin-top: 2px;
  }
  .tooltip-liked {
    color: var(--red); font-size: 10px; font-weight: 600;
    letter-spacing: 0.06em;
  }

  /* ── Legend ── */
  .legend {
    position: fixed; bottom: 48px;
    bottom: max(48px, calc(env(safe-area-inset-bottom, 16px) + 36px));
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    display: flex; align-items: center; gap: 10px;
    font-size: 8px; letter-spacing: 0.05em;
    color: var(--dim); text-transform: uppercase;
    white-space: nowrap;
  }
  .legend-item {
    display: flex; align-items: center; gap: 4px;
  }
  .legend-dot {
    width: 6px; height: 6px; border-radius: 50%;
  }

  /* ── Loading ── */
  #loading {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 16px; z-index: 100;
    background: #050508;
    font-size: 12px; letter-spacing: 0.08em;
    text-transform: uppercase; color: var(--dim);
  }
  @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
  .loading-dot {
    width: 6px; height: 6px;
    background: var(--white);
    border-radius: 50%;
    animation: pulse 1.2s infinite;
  }
  #loading-status { font-size: 10px; margin-top: 4px; }

  /* ── Mobile detail card ── */
  #detail-card {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    z-index: 30;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    pointer-events: none;
  }
  #detail-card.visible {
    transform: translateY(0);
    pointer-events: auto;
  }
  .detail-inner {
    margin: 0 12px 12px;
    margin-bottom: max(12px, calc(env(safe-area-inset-bottom, 12px) + 60px));
    background: rgba(15,15,20,0.95);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px;
    padding: 12px;
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    display: flex; gap: 14px;
    align-items: center;
  }
  .detail-img {
    width: 72px; height: 72px;
    object-fit: cover;
    border-radius: 6px;
    flex-shrink: 0;
    background: #1a1a1a;
  }
  .detail-text {
    flex: 1; min-width: 0;
    display: flex; flex-direction: column; gap: 3px;
  }
  .detail-title {
    font-size: 12px; font-weight: 600;
    line-height: 1.3;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .detail-meta {
    font-size: 9px; color: var(--dim);
    letter-spacing: 0.03em;
  }
  .detail-score {
    font-size: 11px; font-weight: 500;
    margin-top: 2px;
  }
  .detail-liked-badge {
    color: var(--red); font-size: 9px; font-weight: 600;
    letter-spacing: 0.06em;
  }
  .detail-close {
    position: absolute;
    top: 8px; right: 14px;
    background: none; border: none;
    color: var(--dim); font-size: 18px;
    cursor: pointer; padding: 4px;
    -webkit-tap-highlight-color: transparent;
  }

  /* ── Mobile ── */
  @media (max-width: 600px) {
    .hud-stat { font-size: 9px; }
    .mode-btn { font-size: 8px; padding: 4px 6px; }
    .legend { font-size: 7px; gap: 8px; }
    .legend-dot { width: 5px; height: 5px; }
    #tooltip { display: none !important; }
  }
</style>
</head>
<body>

<div id="loading">
  <div class="loading-dot"></div>
  <div>Mapping taste space</div>
  <div id="loading-status"></div>
</div>

<nav class="stv-nav" data-stv-theme="floating" data-stv-page="taste">
  <div class="stv-nav-center">
    <a class="stv-nav-back" href="/">&#8249;</a>
    <span class="stv-nav-title">Taste Map</span>
  </div>
  <div class="stv-nav-right">
    <span class="hud-stat"><b id="total-count">0</b> paintings</span>
    <span class="hud-stat"><b id="liked-count" style="color:var(--red)">0</b> liked</span>
  </div>
</nav>

<div class="color-modes">
  <button class="mode-btn active" data-mode="score">Score</button>
  <button class="mode-btn" data-mode="style">Style</button>
  <button class="mode-btn" data-mode="price">Price</button>
  <button class="mode-btn" data-mode="liked">Liked</button>
  <button class="mode-btn" data-mode="source">Source</button>
</div>

<div class="legend" id="legend"></div>
<div id="tooltip"><div class="tooltip-inner" id="tooltip-inner"></div></div>
<div id="detail-card"><div class="detail-inner" id="detail-inner"><button class="detail-close" id="detail-close">&times;</button></div></div>
<canvas id="canvas"></canvas>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three'
import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

const API = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
  ? `http://${window.location.host}` : ''

const isMobile = window.innerWidth < 600

// ── State ──
let mapData = null
let likedSet = new Set()
let colorMode = 'score'
let hoveredIdx = -1
let userInteracting = false
let interactionTimer = null

// ── Style palette ──
const STYLE_COLORS = {
  'oil painting':       [0.95, 0.50, 0.15],
  'watercolor':         [0.25, 0.60, 0.95],
  'acrylic':            [0.90, 0.25, 0.55],
  'mixed media':        [0.60, 0.85, 0.25],
  'pastel':             [0.75, 0.65, 0.90],
  'ink':                [0.40, 0.40, 0.55],
  'pencil':             [0.65, 0.65, 0.60],
  'digital':            [0.15, 0.90, 0.80],
  'print':              [0.95, 0.80, 0.25],
  'photography':        [0.55, 0.55, 0.65],
  'impressionist':      [0.70, 0.50, 0.85],
  'landscape':          [0.30, 0.75, 0.40],
  'abstract':           [0.85, 0.35, 0.70],
}
const DEFAULT_STYLE_COLOR = [0.30, 0.30, 0.38]

// ── Three.js ──
const canvas = document.getElementById('canvas')
const renderer = new THREE.WebGLRenderer({ canvas, antialias: !isMobile, alpha: true })
renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2))
renderer.setSize(window.innerWidth, window.innerHeight)

const scene = new THREE.Scene()
scene.background = new THREE.Color(0x050508)

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 100)
camera.position.set(0, 0.3, isMobile ? 3.5 : 3.8)

const controls = new OrbitControls(camera, canvas)
controls.enableDamping = true
controls.dampingFactor = 0.04
controls.rotateSpeed = isMobile ? 0.3 : 0.5
controls.zoomSpeed = 0.7
controls.autoRotate = true
controls.autoRotateSpeed = 0.2
controls.minDistance = 0.8
controls.maxDistance = 8
controls.enablePan = !isMobile

// Auto-rotate pauses on interaction, resumes after 3s idle
function onInteractionStart() {
  userInteracting = true
  controls.autoRotate = false
  clearTimeout(interactionTimer)
}
function onInteractionEnd() {
  userInteracting = false
  clearTimeout(interactionTimer)
  interactionTimer = setTimeout(() => {
    if (!userInteracting) controls.autoRotate = true
  }, 3000)
}
controls.addEventListener('start', onInteractionStart)
controls.addEventListener('end', onInteractionEnd)

// ── Shader: additive glow so dense clusters light up ──
const pointsMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uSize: { value: (isMobile ? 0.6 : 0.7) * renderer.getPixelRatio() },
  },
  vertexShader: `
    attribute vec3 customColor;
    attribute float alpha;
    attribute float size;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uSize;

    void main() {
      vColor = customColor;
      vAlpha = alpha;
      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = size * uSize * (70.0 / -mvPos.z);
      gl_PointSize = clamp(gl_PointSize, 0.5, 12.0);
      gl_Position = projectionMatrix * mvPos;
    }
  `,
  fragmentShader: `
    varying vec3 vColor;
    varying float vAlpha;

    void main() {
      vec2 uv = gl_PointCoord - 0.5;
      float d = length(uv);
      if (d > 0.5) discard;
      // Soft glow: bright core + gentle falloff
      float core = smoothstep(0.5, 0.15, d);
      float glow = smoothstep(0.5, 0.0, d) * 0.3;
      float brightness = core + glow;
      gl_FragColor = vec4(vColor * brightness, vAlpha * core);
    }
  `,
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
})

let pointsGeometry = null
let pointsMesh = null

// ── Load ──
async function loadData() {
  const status = document.getElementById('loading-status')
  status.textContent = 'Loading embedding map...'
  const mapRes = await fetch(`${API}/api/taste-map`)
  if (!mapRes.ok) {
    status.textContent = 'Failed to load — run project_3d.py first'
    return
  }
  mapData = await mapRes.json()
  likedSet = new Set(mapData.liked || [])

  status.textContent = 'Building point cloud...'
  await new Promise(r => requestAnimationFrame(r))

  buildPointCloud()

  document.getElementById('total-count').textContent = mapData.ids.length.toLocaleString()
  document.getElementById('liked-count').textContent = likedSet.size
  document.getElementById('loading').style.display = 'none'

  updateColors()
  updateLegend()
}

function buildPointCloud() {
  const n = mapData.ids.length
  const positions = new Float32Array(n * 3)
  const colors = new Float32Array(n * 3)
  const alphas = new Float32Array(n)
  const sizes = new Float32Array(n)

  for (let i = 0; i < n; i++) {
    positions[i * 3]     = mapData.coords[i * 3]
    positions[i * 3 + 1] = mapData.coords[i * 3 + 1]
    positions[i * 3 + 2] = mapData.coords[i * 3 + 2]
    alphas[i] = 0.5
    sizes[i] = 1.0
  }

  pointsGeometry = new THREE.BufferGeometry()
  pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
  pointsGeometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3))
  pointsGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1))
  pointsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1))

  pointsMesh = new THREE.Points(pointsGeometry, pointsMaterial)
  scene.add(pointsMesh)
}

// ── Colors ──
function updateColors() {
  if (!mapData || !pointsGeometry) return
  const n = mapData.ids.length
  const colors = pointsGeometry.attributes.customColor.array
  const alphas = pointsGeometry.attributes.alpha.array
  const sizes = pointsGeometry.attributes.size.array

  for (let i = 0; i < n; i++) {
    const m = mapData.meta[i]
    const isLiked = likedSet.has(mapData.ids[i])
    let r, g, b, a = 0.25, s = 0.8

    switch (colorMode) {
      case 'score': {
        const t = Math.min(1, Math.max(0, (m.s || 0) / 100))
        // Deep blue → teal → warm gold
        if (t < 0.4) {
          const u = t / 0.4
          r = 0.06 + u * 0.08; g = 0.08 + u * 0.15; b = 0.25 + u * 0.20
        } else if (t < 0.7) {
          const u = (t - 0.4) / 0.3
          r = 0.14 + u * 0.45; g = 0.23 + u * 0.35; b = 0.45 + u * 0.05
        } else {
          const u = (t - 0.7) / 0.3
          r = 0.59 + u * 0.41; g = 0.58 + u * 0.25; b = 0.50 - u * 0.25
        }
        a = 0.10 + t * 0.40
        s = 0.3 + t * 1.2
        break
      }
      case 'style': {
        const sc = STYLE_COLORS[m.st] || DEFAULT_STYLE_COLOR
        r = sc[0]; g = sc[1]; b = sc[2]
        a = m.st ? 0.35 : 0.04
        s = m.st ? 0.8 : 0.2
        break
      }
      case 'price': {
        const p = m.p || 0
        if (p === 0) { r = 0.10; g = 0.10; b = 0.12; a = 0.03; s = 0.2 }
        else {
          const t = Math.min(1, Math.max(0, Math.log10(Math.max(1, p)) / 4))
          r = 0.10 + t * 0.85; g = 0.55 - t * 0.30; b = 0.20 - t * 0.10
          a = 0.15 + t * 0.35
          s = 0.4 + t * 1.0
        }
        break
      }
      case 'liked': {
        if (isLiked) {
          r = 1.0; g = 0.20; b = 0.15; a = 0.95; s = 3.0
        } else {
          r = 0.15; g = 0.15; b = 0.20; a = 0.05; s = 0.25
        }
        break
      }
      case 'source': {
        if (m.src === 'cl' || m.src === 'craigslist') {
          r = 0.25; g = 0.55; b = 0.95; a = 0.30; s = 0.7
        } else if (m.src === 'eb' || m.src === 'ebay') {
          r = 0.95; g = 0.50; b = 0.15; a = 0.30; s = 0.7
        } else {
          r = 0.25; g = 0.25; b = 0.30; a = 0.08; s = 0.3
        }
        break
      }
    }

    if (isLiked && colorMode !== 'liked') {
      a = Math.max(a, 0.55)
      s = Math.max(s, 2.0)
    }

    colors[i * 3] = r; colors[i * 3 + 1] = g; colors[i * 3 + 2] = b
    alphas[i] = a
    sizes[i] = s
  }

  pointsGeometry.attributes.customColor.needsUpdate = true
  pointsGeometry.attributes.alpha.needsUpdate = true
  pointsGeometry.attributes.size.needsUpdate = true
}

function updateLegend() {
  const legend = document.getElementById('legend')
  let html = ''
  switch (colorMode) {
    case 'score':
      html = `
        <div class="legend-item"><div class="legend-dot" style="background:#1a2050"></div>Low</div>
        <div class="legend-item"><div class="legend-dot" style="background:#3a8070"></div>Mid</div>
        <div class="legend-item"><div class="legend-dot" style="background:#fca830"></div>High</div>
      `; break
    case 'style':
      for (const [style, [cr,cg,cb]] of Object.entries(STYLE_COLORS).slice(0, isMobile ? 4 : 6)) {
        const hex = `rgb(${Math.round(cr*255)},${Math.round(cg*255)},${Math.round(cb*255)})`
        const label = style.replace(/\b\w/g, c => c.toUpperCase())
        html += `<div class="legend-item"><div class="legend-dot" style="background:${hex}"></div>${label}</div>`
      }
      break
    case 'price':
      html = `
        <div class="legend-item"><div class="legend-dot" style="background:#222"></div>Free</div>
        <div class="legend-item"><div class="legend-dot" style="background:#3a9040"></div>$10</div>
        <div class="legend-item"><div class="legend-dot" style="background:#e07020"></div>$1K+</div>
      `; break
    case 'liked':
      html = `
        <div class="legend-item"><div class="legend-dot" style="background:#e53e3e"></div>Liked</div>
        <div class="legend-item"><div class="legend-dot" style="background:#282830"></div>Other</div>
      `; break
    case 'source':
      html = `
        <div class="legend-item"><div class="legend-dot" style="background:#408cf2"></div>Craigslist</div>
        <div class="legend-item"><div class="legend-dot" style="background:#f28030"></div>eBay</div>
      `; break
  }
  legend.innerHTML = html
}

// ── Mode buttons ──
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelector('.mode-btn.active').classList.remove('active')
    btn.classList.add('active')
    colorMode = btn.dataset.mode
    updateColors()
    updateLegend()
  })
})

// ── Raycasting (desktop only) ──
const raycaster = new THREE.Raycaster()
raycaster.params.Points.threshold = 0.025
const mouse = new THREE.Vector2()
const tooltip = document.getElementById('tooltip')
const tooltipInner = document.getElementById('tooltip-inner')

if (!isMobile) {
  // Desktop: hover tooltip + click to open listing
  canvas.addEventListener('mousemove', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1
    raycaster.setFromCamera(mouse, camera)
    const intersects = raycaster.intersectObject(pointsMesh)
    if (intersects.length > 0) {
      const idx = intersects[0].index
      if (idx !== hoveredIdx) {
        hoveredIdx = idx
        showTooltip(idx, e.clientX, e.clientY)
      } else {
        positionTooltip(e.clientX, e.clientY)
      }
      canvas.style.cursor = 'pointer'
    } else {
      hoveredIdx = -1
      tooltip.style.display = 'none'
      canvas.style.cursor = 'grab'
    }
  })

  canvas.addEventListener('click', () => {
    if (hoveredIdx >= 0 && mapData) {
      const m = mapData.meta[hoveredIdx]
      if (m.u) window.open(m.u, '_blank')
    }
  })
} else {
  // Mobile: tap to show detail card, tap empty to dismiss
  const detailCard = document.getElementById('detail-card')
  const detailInner = document.getElementById('detail-inner')
  const detailClose = document.getElementById('detail-close')
  let tapStart = 0
  let tapMoved = false

  canvas.addEventListener('touchstart', (e) => {
    tapStart = Date.now()
    tapMoved = false
  }, { passive: true })

  canvas.addEventListener('touchmove', () => { tapMoved = true }, { passive: true })

  canvas.addEventListener('touchend', (e) => {
    if (tapMoved || Date.now() - tapStart > 400) return
    const touch = e.changedTouches[0]
    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1
    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1

    raycaster.params.Points.threshold = 0.04
    raycaster.setFromCamera(mouse, camera)
    const intersects = raycaster.intersectObject(pointsMesh)

    if (intersects.length > 0) {
      const idx = intersects[0].index
      showDetailCard(idx)
    } else {
      hideDetailCard()
    }
  })

  detailClose.addEventListener('click', (e) => {
    e.stopPropagation()
    hideDetailCard()
  })

  function showDetailCard(idx) {
    if (!mapData) return
    const m = mapData.meta[idx]
    const isLiked = likedSet.has(mapData.ids[idx])

    detailInner.innerHTML = `
      <button class="detail-close" onclick="document.getElementById('detail-card').classList.remove('visible')">&times;</button>
      ${m.img ? `<img class="detail-img" src="${m.img}" alt="">` : ''}
      <div class="detail-text">
        <div class="detail-title">${esc(m.t || 'Untitled')}</div>
        <div class="detail-meta">${[m.a, m.st, m.r].filter(Boolean).join(' \u00b7 ')}</div>
        <div class="detail-score" style="color:${scoreColor(m.s)}">Score ${m.s}${m.p ? ` \u00b7 $${m.p}` : ''}</div>
        ${isLiked ? '<div class="detail-liked-badge">LIKED</div>' : ''}
      </div>
    `
    detailCard.classList.add('visible')
  }

  function hideDetailCard() {
    detailCard.classList.remove('visible')
  }
}

function showTooltip(idx, mx, my) {
  if (!mapData) return
  const m = mapData.meta[idx]
  const isLiked = likedSet.has(mapData.ids[idx])
  tooltipInner.innerHTML = `
    ${m.img ? `<img class="tooltip-img" src="${m.img}" alt="">` : ''}
    <div class="tooltip-text">
      <div class="tooltip-title">${esc(m.t || 'Untitled')}</div>
      <div class="tooltip-meta">${[m.a, m.st, m.r].filter(Boolean).join(' · ')}</div>
      <div class="tooltip-score" style="color:${scoreColor(m.s)}">Score ${m.s}${m.p ? ` · $${m.p}` : ''}</div>
      ${isLiked ? '<div class="tooltip-liked">LIKED</div>' : ''}
    </div>
  `
  tooltip.style.display = 'block'
  positionTooltip(mx, my)
}

function positionTooltip(mx, my) {
  const pad = 16
  let x = mx + pad, y = my + pad
  const rect = tooltip.getBoundingClientRect()
  if (x + rect.width > window.innerWidth) x = mx - rect.width - pad
  if (y + rect.height > window.innerHeight) y = my - rect.height - pad
  tooltip.style.left = x + 'px'
  tooltip.style.top = y + 'px'
}

function scoreColor(s) {
  const t = Math.min(1, Math.max(0, s / 100))
  if (t < 0.5) return `rgb(${Math.round(30 + t * 200)}, ${Math.round(40 + t * 300)}, ${Math.round(100 + t * 200)})`
  const u = (t - 0.5) * 2
  return `rgb(${Math.round(230 + u * 25)}, ${Math.round(210 - u * 30)}, ${Math.round(200 - u * 140)})`
}

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML }

// ── Resize ──
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
})

// ── Animate ──
function animate() {
  requestAnimationFrame(animate)
  controls.update()
  renderer.render(scene, camera)
}
animate()
loadData()
</script>
<script src="stv-nav.js"></script>
</body>
</html>
