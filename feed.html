<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<title>STEVENSON — Feed</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --font: 'IBM Plex Mono', monospace;
    --black: #0a0a0a;
    --white: #fff;
    --gray: #888;
    --dim: rgba(255,255,255,0.5);
    --red: #e53e3e;
  }

  html, body {
    height: 100%;
    overflow: hidden;
    font-family: var(--font);
    background: var(--black);
    color: var(--white);
    -webkit-font-smoothing: antialiased;
    touch-action: pan-y;
  }

  /* ─── FEED ─── */
  #feed {
    width: 100%;
    height: 100%;
    overflow-y: scroll;
    scroll-snap-type: y mandatory;
    -webkit-overflow-scrolling: touch;
  }
  #feed::-webkit-scrollbar { width: 0; height: 0; }

  /* ─── CARD ─── */
  .card {
    width: 100%;
    height: 100vh;
    height: 100dvh;
    scroll-snap-align: start;
    scroll-snap-stop: always;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    background: var(--black);
  }

  .card-img {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: contain;
    z-index: 1;
    user-select: none;
    -webkit-user-drag: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  .card-img.loaded { opacity: 1; }

  /* image placeholder shimmer */
  .card-shimmer {
    position: absolute;
    inset: 20%;
    background: linear-gradient(110deg, transparent 30%, rgba(255,255,255,0.04) 50%, transparent 70%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    z-index: 0;
  }
  @keyframes shimmer { to { background-position: -200% 0; } }

  /* vignette */
  .card::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(to top,
      rgba(0,0,0,0.65) 0%, rgba(0,0,0,0) 30%,
      rgba(0,0,0,0) 75%, rgba(0,0,0,0.3) 100%);
    z-index: 2;
    pointer-events: none;
  }

  /* ─── CARD INFO ─── */
  .card-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 70px;
    padding: 20px;
    padding-bottom: max(20px, env(safe-area-inset-bottom, 20px));
    z-index: 3;
  }

  .card-title {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 0.02em;
    line-height: 1.3;
    color: var(--white);
    text-shadow: 0 1px 4px rgba(0,0,0,0.6);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .card-meta {
    font-size: 11px;
    color: var(--dim);
    margin-top: 4px;
    letter-spacing: 0.02em;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  }

  .card-badges {
    display: flex;
    gap: 6px;
    margin-top: 6px;
  }

  .badge {
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 2px 6px;
    border-radius: 3px;
    background: rgba(255,255,255,0.12);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    color: var(--dim);
    text-shadow: none;
  }
  .badge.taste { color: #a78bfa; background: rgba(167,139,250,0.15); }
  .badge.quality { color: #fbbf24; background: rgba(251,191,36,0.15); }
  .badge.explore { color: #34d399; background: rgba(52,211,153,0.15); }

  /* ─── ACTIONS ─── */
  .card-actions {
    position: absolute;
    right: 14px;
    bottom: 90px;
    bottom: calc(90px + env(safe-area-inset-bottom, 0px));
    z-index: 3;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 18px;
  }

  .action-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
    background: none;
    border: none;
    cursor: pointer;
    color: var(--white);
    -webkit-tap-highlight-color: transparent;
  }

  .action-icon {
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.5));
    transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  .action-label {
    font-family: var(--font);
    font-size: 10px;
    letter-spacing: 0.04em;
    color: var(--dim);
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  }

  .action-btn.liked .action-icon { color: var(--red); transform: scale(1.1); }
  .action-btn.liked .action-label { color: var(--red); }

  @keyframes heartPop {
    0% { transform: scale(1); }
    30% { transform: scale(1.4); }
    60% { transform: scale(0.95); }
    100% { transform: scale(1.1); }
  }
  .action-btn.pop .action-icon {
    animation: heartPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  /* double-tap burst */
  @keyframes heartBurst {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(0); }
    40% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.8); }
  }
  .heart-burst {
    position: absolute;
    top: 50%;
    left: 50%;
    font-size: 80px;
    z-index: 10;
    pointer-events: none;
    color: var(--red);
    animation: heartBurst 0.7s ease-out forwards;
  }

  /* ─── TOP BAR ─── */
  .top-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 12px 20px;
    padding-top: max(12px, env(safe-area-inset-top, 12px));
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: space-between;
    pointer-events: none;
  }
  .top-bar > * { pointer-events: auto; }

  .top-title {
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--white);
    text-shadow: 0 1px 4px rgba(0,0,0,0.5);
    text-decoration: none;
  }

  .top-right {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 11px;
    color: var(--dim);
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  }

  .heart-count { color: var(--red); font-weight: 500; }

  .strategy-pill {
    font-size: 9px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 2px 6px;
    border-radius: 10px;
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(8px);
  }

  /* ─── LOADING ─── */
  .loading-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    color: var(--gray);
    font-size: 12px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }
  @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
  .loading-dot {
    width: 6px; height: 6px;
    background: var(--white);
    border-radius: 50%;
    animation: pulse 1.2s infinite;
  }
</style>
</head>
<body>

<div class="top-bar">
  <a href="/" class="top-title">STEVENSON</a>
  <div class="top-right">
    <span class="heart-count" id="like-count">0</span> liked
    <span id="strategy-pill" class="strategy-pill" style="display:none"></span>
  </div>
</div>

<div id="feed">
  <div class="card loading-card" id="initial-loading">
    <div class="loading-dot"></div>
    <div>Loading feed</div>
  </div>
</div>

<script>
const API = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
  ? `http://${window.location.host}` : ''

// ─── State ───
let paintings = []       // all loaded paintings
let likedSet = new Set() // server-side liked IDs
let seenIds = new Set()  // IDs we've been served (for exclusion)
let currentIndex = 0
let isFetching = false
let fetchQueue = null     // debounced taste re-fetch after like

const BUFFER_AHEAD = 5   // pre-fetch when this many cards left
const FETCH_SIZE = 15     // cards per fetch
const INITIAL_SIZE = 20   // first load

// ─── Init ───
async function init() {
  await fetchBatch(INITIAL_SIZE)
  setupScroll()
  setupKeys()
}

// ─── Fetch a batch from the smart feed API ───
async function fetchBatch(size) {
  if (isFetching) return
  isFetching = true

  try {
    const res = await fetch(`${API}/api/feed`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        seen: Array.from(seenIds).slice(-300),
        size,
      }),
    })
    const data = await res.json()

    // Update likes from server
    likedSet = new Set(data.liked || [])
    updateLikeCount()

    // Show strategy
    if (data.meta) {
      const pill = document.getElementById('strategy-pill')
      if (data.meta.strategy === 'poles') {
        pill.textContent = `${data.meta.poles} taste poles`
        pill.style.display = ''
      } else if (data.meta.strategy === 'simple') {
        pill.textContent = 'learning'
        pill.style.display = ''
      } else {
        pill.textContent = 'discover'
        pill.style.display = ''
      }
    }

    const newPaintings = data.paintings || []
    if (!newPaintings.length && !paintings.length) {
      document.getElementById('feed').innerHTML =
        '<div class="card loading-card"><div>No paintings yet</div><div style="font-size:10px;margin-top:4px;color:#555">Embeddings may still be processing</div></div>'
      isFetching = false
      return
    }

    // Add to state
    for (const p of newPaintings) {
      seenIds.add(p.id)
    }
    const startIdx = paintings.length
    paintings.push(...newPaintings)

    // Remove initial loading card
    const loadingCard = document.getElementById('initial-loading')
    if (loadingCard) loadingCard.remove()

    // Render new cards
    renderCards(newPaintings, startIdx)

  } catch (e) {
    console.error('Feed fetch failed:', e)
    if (!paintings.length) {
      document.getElementById('feed').innerHTML =
        '<div class="card loading-card"><div>Failed to load</div></div>'
    }
  }

  isFetching = false
}

// ─── Render cards into DOM ───
function renderCards(newPaintings, startIdx) {
  const feed = document.getElementById('feed')

  for (let i = 0; i < newPaintings.length; i++) {
    const idx = startIdx + i
    const p = newPaintings[i]
    const imgUrl = p.images && p.images[0] ? p.images[0] : ''
    const isLiked = likedSet.has(p.id)
    const price = p.price ? `$${Math.round(p.price)}` : ''
    const location = p.location || p.region || ''
    const artist = p.artist || ''
    const meta = [artist, price, location].filter(Boolean).join(' · ')
    const score = p.art_score ? Math.round(p.art_score) : ''
    const reason = p._reason || ''

    const card = document.createElement('div')
    card.className = 'card'
    card.dataset.idx = idx
    card.dataset.id = p.id

    card.innerHTML = `
      <div class="card-shimmer"></div>
      ${imgUrl ? `<img class="card-img" src="${imgUrl}" alt="" draggable="false"
        onload="this.classList.add('loaded'); this.previousElementSibling.remove()">` : ''}
      <div class="card-info">
        <div class="card-title">${esc(p.title || 'Untitled')}</div>
        ${meta ? `<div class="card-meta">${esc(meta)}</div>` : ''}
        <div class="card-badges">
          ${score ? `<span class="badge">${score}</span>` : ''}
          ${reason ? `<span class="badge ${reason}">${reason}</span>` : ''}
        </div>
      </div>
      <div class="card-actions">
        <button class="action-btn like-btn${isLiked ? ' liked' : ''}" data-idx="${idx}" aria-label="Like">
          <span class="action-icon">${isLiked ? '&#9829;' : '&#9825;'}</span>
          <span class="action-label">like</span>
        </button>
        <button class="action-btn" onclick="openListing(${idx})" aria-label="View">
          <span class="action-icon" style="font-size:22px">&#8599;</span>
          <span class="action-label">view</span>
        </button>
      </div>
    `

    // Like button
    card.querySelector('.like-btn').addEventListener('click', (e) => {
      e.stopPropagation()
      toggleLike(idx)
    })

    // Double-tap to like
    let lastTap = 0
    card.addEventListener('touchend', (e) => {
      const now = Date.now()
      if (now - lastTap < 300) {
        e.preventDefault()
        if (!likedSet.has(p.id)) toggleLike(idx)
        showHeartBurst(card)
      }
      lastTap = now
    })
    card.addEventListener('dblclick', (e) => {
      e.preventDefault()
      if (!likedSet.has(p.id)) toggleLike(idx)
      showHeartBurst(card)
    })

    // Preload next image
    if (i < 3 || idx - currentIndex < BUFFER_AHEAD + 3) {
      const img = card.querySelector('.card-img')
      if (img) img.loading = 'eager'
    }

    feed.appendChild(card)
  }
}

// ─── Scroll handling ───
function setupScroll() {
  const feed = document.getElementById('feed')
  let scrollTimer

  feed.addEventListener('scroll', () => {
    clearTimeout(scrollTimer)
    scrollTimer = setTimeout(() => {
      const idx = Math.round(feed.scrollTop / window.innerHeight)
      if (idx !== currentIndex) {
        currentIndex = idx

        // Pre-fetch trigger: when within BUFFER_AHEAD of end
        const remaining = paintings.length - currentIndex - 1
        if (remaining <= BUFFER_AHEAD) {
          fetchBatch(FETCH_SIZE)
        }
      }
    }, 60)
  }, { passive: true })
}

// ─── Keyboard nav ───
function setupKeys() {
  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown' || e.key === 'j') {
      e.preventDefault()
      goTo(currentIndex + 1)
    } else if (e.key === 'ArrowUp' || e.key === 'k') {
      e.preventDefault()
      goTo(currentIndex - 1)
    } else if (e.key === 'l' || e.key === 'L') {
      toggleLike(currentIndex)
    } else if (e.key === 'Enter' || e.key === 'o') {
      openListing(currentIndex)
    }
  })
}

function goTo(idx) {
  const feed = document.getElementById('feed')
  if (idx >= 0 && idx < feed.children.length) {
    currentIndex = idx
    feed.children[idx].scrollIntoView({ behavior: 'smooth' })

    // Pre-fetch check
    const remaining = paintings.length - idx - 1
    if (remaining <= BUFFER_AHEAD) {
      fetchBatch(FETCH_SIZE)
    }
  }
}

// ─── Like system ───
async function toggleLike(idx) {
  const p = paintings[idx]
  if (!p) return

  const nowLiked = !likedSet.has(p.id)
  if (nowLiked) likedSet.add(p.id)
  else likedSet.delete(p.id)

  updateCardLike(idx, nowLiked)
  updateLikeCount()

  // Persist
  try {
    await fetch(`${API}/api/like`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: p.id, liked: nowLiked }),
    })
  } catch {
    // Revert
    if (nowLiked) likedSet.delete(p.id)
    else likedSet.add(p.id)
    updateCardLike(idx, !nowLiked)
    updateLikeCount()
    return
  }

  // Schedule taste re-fetch: debounced 600ms after last like
  // This ensures the NEXT batch reflects updated taste
  clearTimeout(fetchQueue)
  fetchQueue = setTimeout(() => {
    // Only fetch if we're getting close to the end
    const remaining = paintings.length - currentIndex - 1
    if (remaining <= BUFFER_AHEAD + 5) {
      fetchBatch(FETCH_SIZE)
    }
  }, 600)
}

function updateCardLike(idx, liked) {
  const card = document.querySelectorAll('.card')[idx]
  if (!card) return
  const btn = card.querySelector('.like-btn')
  if (!btn) return
  btn.classList.toggle('liked', liked)
  btn.classList.add('pop')
  setTimeout(() => btn.classList.remove('pop'), 400)
  btn.querySelector('.action-icon').innerHTML = liked ? '&#9829;' : '&#9825;'
}

function showHeartBurst(card) {
  const heart = document.createElement('div')
  heart.className = 'heart-burst'
  heart.innerHTML = '&#9829;'
  card.appendChild(heart)
  setTimeout(() => heart.remove(), 700)
}

function openListing(idx) {
  const p = paintings[idx]
  if (p && p.url) window.open(p.url, '_blank')
}

function updateLikeCount() {
  document.getElementById('like-count').textContent = likedSet.size
}

function esc(s) {
  const d = document.createElement('div')
  d.textContent = s
  return d.innerHTML
}

init()
</script>
</body>
</html>
